<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Database</title>
</head>
<body>
    <link rel="stylesheet" href="style.css">
    <h1>Database 2</h1>
    <center>
<div id="copyNotification" class="copy-notification">URL Copied!</div>
         <!-- Input fields for XXX and YYY -->
        <label for="inputXXX">Username:</label>
        <input type="text" id="inputXXX" placeholder="Enter Username..." oninput="updateTable()">
        <label for="inputYYY">Password:</label>
        <input type="text" id="inputYYY" placeholder="Enter Password..." oninput="updateTable()">
<br><br>
        <input type="text" id="searchInput" placeholder="Chanel/Movie...">
        <button onclick="filter()">Filter</button>

       
        <!-- Button to fetch CSV from GitHub -->
        <!-- <button onclick="fetchCSVFromGitHub()">Fetch CSV from GitHub</button> -->
    </center>

    <div id="tableContainer">
        <table id="dataTable" style="display: none;"></table>
    </div>

    <script>
        var csvData = [];

        // Function to fetch CSV data from GitHub
        function fetchCSVFromGitHub() {
            fetch('https://raw.githubusercontent.com/Xebilon/Xebilon.github.io/main/Bok2.csv')
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok');
                    }
                    return response.text();
                })
                .then(csvText => {
                    csvData = csvText.split('\n').map(row => row.split(','));

                    // Convert CSV data to array of objects
                    csvData = csvData.slice(1).map(row => {
                        return {
                            ChannelName: row[2],
                            StreamURL: row[8]
                        };
                    });

                    // Populate table with rows as they are loaded
                    updateTable();
                })
                .catch(error => {
                    console.error('Error fetching CSV data:', error);
                });
        }

      // Function to update table
function updateTable() {
    var inputXXX = document.getElementById('inputXXX').value;
    var inputYYY = document.getElementById('inputYYY').value;

    // Check if input values are not empty
    if (inputXXX.trim() !== '' && inputYYY.trim() !== '') {
        var tableHTML = '<tr><th>Channel Name</th><th>Stream URL</th><th>Play URL</th></tr>';
        var dataTable = document.getElementById('dataTable');
        csvData.forEach(row => {
            var rowHTML = '<tr>';
            
            rowHTML += '<td>' + row.ChannelName + '</td>';

            // Replace XXX and YYY in the Stream URL with user input values
            var streamURL = row.StreamURL.replace('XXX', inputXXX).replace('YYY', inputYYY);

         // Create a hyperlink to copy the stream URL to clipboard
var copyLinkHTML = '<td><a href="#" onclick="copyToClipboard(\'' + streamURL + '\', event)">Copy</a></td>';
rowHTML += copyLinkHTML;

             // Create a hyperlink to play the stream
                 var playLinkHTML = '<td><a href="#" onclick="startVideo(\'' + streamURL + '\');">Play</a></td>';
rowHTML += playLinkHTML;


            rowHTML += '</tr>';
            tableHTML += rowHTML;
        });
        dataTable.innerHTML = tableHTML;
        
        // Show table
        dataTable.style.display = 'table'; // or 'block' if you prefer
    } else {
        // Clear the table if input values are empty
        document.getElementById('dataTable').innerHTML = '';
    }
}

     // Function to filter data
function filter() {
    var searchTerm = document.getElementById('searchInput').value.toLowerCase();
    var filteredData = csvData.filter(row => {
        // Check if the row has the 'Channel Name' property and if it includes the search term
        return row.ChannelName && row.ChannelName.toLowerCase().includes(searchTerm);
    });

    var tableHTML = '<tr><th>Channel Name</th><th>Stream URL</th><th>Play URL</th></tr>';
    for (var i = 0; i < filteredData.length; i++) {
        var row = filteredData[i];
        var rowHTML = '<tr>';
    
        rowHTML += '<td>' + row.ChannelName + '</td>';

        // Replace XXX and YYY in the Stream URL with user input values
        var inputXXX = document.getElementById('inputXXX').value;
        var inputYYY = document.getElementById('inputYYY').value;
        var streamURL = row.StreamURL.replace('XXX', inputXXX).replace('YYY', inputYYY);

      // Create a hyperlink to copy the stream URL to clipboard
var copyLinkHTML = '<td><a href="#" onclick="copyToClipboard(\'' + streamURL + '\', event)">Copy</a></td>';
rowHTML += copyLinkHTML;

                // Create a hyperlink to play the stream
                var playLinkHTML = '<td><a href="#" onclick="startVideo(\'' + streamURL + '\');">Play</a></td>';
rowHTML += playLinkHTML;

        rowHTML += '</tr>';
        tableHTML += rowHTML;
    }

    var dataTable = document.getElementById('dataTable');
    dataTable.innerHTML = tableHTML;
    dataTable.style.display = filteredData.length > 0 ? 'table' : 'none'; // Show table if data found, hide otherwise
}


// Function to copy text to clipboard
function copyToClipboard(url, event) {
    var textarea = document.createElement('textarea');
    textarea.value = url;
    document.body.appendChild(textarea);
    textarea.select();
    document.execCommand('copy');
    document.body.removeChild(textarea);

    // Create and position the notification window
    var notification = document.createElement('div');
    notification.textContent = 'URL copied! Paste it in VLC.';
    notification.className = 'copy-notification';

    // Position the notification near the mouse pointer or the clicked link
    notification.style.top = (event.pageY || event.clientY + document.documentElement.scrollTop) + 'px';
    notification.style.left = (event.pageX || event.clientX + document.documentElement.scrollLeft) + 'px';

    document.body.appendChild(notification);

    // Remove the notification after a delay
    setTimeout(function() {
        document.body.removeChild(notification);
    }, 2000);
}



        // Fetch CSV data from GitHub when the page loads
        window.onload = fetchCSVFromGitHub;
    </script>

    
<style>
    /* CSS styles for video player */
    #videoPlayer {
        max-width: 800px;
        margin: 0 auto;
    }

    .controls {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-top: 10px;
    }
</style>


<!-- Video player container -->
<div id="videoPlayer">
    <video id="videoElement" controls style="width: 100%;">
        Your browser does not support the video tag.
    </video>
    <!-- Controls -->
    <div class="controls">
        <button id="playPauseButton">Play</button>
        <input id="volumeControl" type="range" min="0" max="1" step="0.1" value="1">
        <button id="fullscreenButton">Fullscreen</button>
        <button id="pipButton">PIP</button>
        <select id="resolutionSelect">
            <!-- Options will be dynamically added here -->
        </select>
        <select id="subtitlesSelect">
            <!-- Options will be dynamically added here -->
        </select>
    </div>
</div>

<script>
document.addEventListener("DOMContentLoaded", function() {
    var videoElement = document.getElementById("videoElement");
    var playPauseButton = document.getElementById("playPauseButton");
    var volumeControl = document.getElementById("volumeControl");
    var fullscreenButton = document.getElementById("fullscreenButton");
    var pipButton = document.getElementById("pipButton");
    var resolutionSelect = document.getElementById("resolutionSelect");
    var subtitlesSelect = document.getElementById("subtitlesSelect");

    // Play/Pause button functionality
    playPauseButton.addEventListener("click", function() {
        if (videoElement.paused || videoElement.ended) {
            videoElement.play();
            playPauseButton.textContent = "Pause";
        } else {
            videoElement.pause();
            playPauseButton.textContent = "Play";
        }
    });

    // Volume control functionality
    volumeControl.addEventListener("input", function() {
        videoElement.volume = this.value;
    });

    // Fullscreen button functionality
    fullscreenButton.addEventListener("click", function() {
        if (videoElement.requestFullscreen) {
            videoElement.requestFullscreen();
        } else if (videoElement.mozRequestFullScreen) {
            videoElement.mozRequestFullScreen();
        } else if (videoElement.webkitRequestFullscreen) {
            videoElement.webkitRequestFullscreen();
        } else if (videoElement.msRequestFullscreen) {
            videoElement.msRequestFullscreen();
        }
    });

    // Picture-in-Picture mode functionality
    pipButton.addEventListener("click", function() {
        if (videoElement !== document.pictureInPictureElement) {
            videoElement.requestPictureInPicture();
        } else {
            document.exitPictureInPicture();
        }
    });

    // Parse video URL to determine available resolutions and subtitles
    var videoUrl = videoElement.src;
    var resolutions = []; // Placeholder for available resolutions
    var subtitles = []; // Placeholder for available subtitles

    // Update resolution options
    resolutions.forEach(function(resolution) {
        var option = document.createElement("option");
        option.value = resolution;
        option.textContent = resolution + "p";
        resolutionSelect.appendChild(option);
    });

    // Update subtitles options
    subtitles.forEach(function(subtitle) {
        var option = document.createElement("option");
        option.value = subtitle.src;
        option.textContent = subtitle.label;
        subtitlesSelect.appendChild(option);
    });

    // Set default resolution and subtitles
    var defaultResolution = "720"; // Example: Default resolution is 720p
    var defaultSubtitleSrc = ""; // Example: Default subtitle is empty

    // Change video source based on default resolution
    videoElement.src = videoUrl.replace(/_\d+p/, "_" + defaultResolution + "p");

    // Change subtitle track based on default subtitle
    if (defaultSubtitleSrc) {
        videoElement.textTracks.forEach(function(track) {
            if (track.src === defaultSubtitleSrc) {
                track.mode = "showing";
            } else {
                track.mode = "hidden";
            }
        });
    }

    // Change video source based on selected resolution
    resolutionSelect.addEventListener("change", function() {
        var selectedResolution = this.value;
        videoElement.src = videoUrl.replace(/_\d+p/, "_" + selectedResolution + "p");
    });

    // Toggle subtitles track
    subtitlesSelect.addEventListener("change", function() {
        var selectedSubtitleSrc = this.value;
        videoElement.textTracks.forEach(function(track) {
            if (track.src === selectedSubtitleSrc) {
                track.mode = "showing";
            } else {
                track.mode = "hidden";
            }
        });
    });
});
// Function to fetch the video data via proxy
async function fetchVideoData(url) {
    try {
        const response = await fetch('https://corsproxy.io/?' + url);
        if (!response.ok) {
            throw new Error('Failed to fetch video');
        }
        return await response.blob();
    } catch (error) {
        console.error('Proxy error:', error.message);
        throw error;
    }
}

// Function to start playing the video when the "Play" link is clicked
async function startVideo(url) {
    try {
        const response = await fetch('proxy.php?url=' + encodeURIComponent(streamURL));
        if (!response.ok) {
            throw new Error('Failed to fetch video');
        }
        const videoBlob = await response.blob();
        const videoUrl = URL.createObjectURL(videoBlob);
        var videoElement = document.getElementById("videoElement");
        videoElement.src = videoUrl;
        videoElement.play();
    } catch (error) {
        console.error('Proxy error:', error.message);
        // Handle errors
    }
    return false; // Prevent default behavior of the link
}

</script>



</body>
</html>
